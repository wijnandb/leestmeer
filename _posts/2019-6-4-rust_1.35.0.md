---
layout: post
title: "Rust 1.35.0"
date: Tue, 04 Jun 2019 15:27:00 GMT
category: tech
externe_link: "https://tweakers.net/downloads/48492/rust-1350.html"
---

Rust is een programmeertaal bedacht door Graydon Hoare en oorspronkelijk ontwikkeld door Mozilla. Het is deels geïnspireerd op de programmeertaal C, maar kent syntactische en semantische verschillen. Het focust op veiligheid en beoogt moderne computersystemen efficiënter te benutten. Het wordt ingezet door onder ander Cloudflare, OVH, Mozilla, Deliveroo, Coursera, AppSignal en Threema. Versie 1.35.0 is onlangs uitgebracht met de volgende aankondiging: Announcing Rust 1.35.0 The Rust team is happy to announce a new version of Rust, 1.35.0. Rust is a programming language that is empowering everyone to build reliable and efficient software. If you have a previous version of Rust installed via rustup, getting Rust 1.35.0 is as easy as: $ rustup update stable If you don't have it already, you can get rustup from the appropriate page on our website, and check out the detailed release notes for 1.35.0 on GitHub. What's in 1.35.0 stable The highlight of this release is the implementation of the FnOnce, FnMut, and Fn closure traits for Box, Box, and Box respectively. Additionally, closures may now be coerced to unsafe function pointers. The dbg! macro introduced in Rust 1.32.0 can now also be called without arguments. Moreover, there were a number of standard library stabilizations. Read on for a few highlights, or see the detailed release notes for additional information. Fn* closure traits implemented for Box In Rust 1.35.0, the FnOnce, FnMut, and the Fn traits are now implemented for Box, Box, and Box respectively. Previously, if you wanted to call the function stored in a boxed closure, you had to use FnBox. This was because instances of Box and friends did not implement the respective Fn* traits. This also meant that it was not possible to pass boxed functions to code expecting an implementor of a Fn trait, and you had to create temporary closures to pass them down. This was ultimately due to a limitation in the compiler's ability to reason about such implementations, which has since been fixed with the introduction of unsized locals. With this release, you can now use boxed functions in places that expect items implementing a function trait. The following code now works: fn foo(x: Box u8>) -> Vec { vec![1, 2, 3, 4].into_iter().map(x).collect() } Furthermore, you can now directly call Box objects: fn foo(x: Box) { x() } Coercing closures to unsafe fn pointers Since Rust 1.19.0, it has been possible to coerce closures that do not capture from their environment into function pointers. For example, you may write: fn twice(x: u8, f: fn(u8) -> u8) -> u8 { f(f(x)) } fn main() { assert_eq!(42, twice(0, |x| x + 21)); } This has however not extended to unsafe function pointers. With this release of Rust, you may now do so. For example: /// The safety invariants are those of the `unsafe fn` pointer passed. unsafe fn call_unsafe_fn_ptr(f: unsafe fn()) { f() } fn main() { // SAFETY: There are no invariants. // The closure is statically prevented from doing unsafe things. unsafe { call_unsafe_fn_ptr(|| { dbg!(); }); } } Calling dbg!() with no argument For the benefit of all the occasional and frequent "print debuggers" out there, Rust 1.32.0 saw the release of the dbg! macro. To recap, the macro allows you to quickly inspect the value of some expression with context. For example, when running: fn main() { let mut x = 0; if dbg!(x == 1) { x += 1; } dbg!(x); } ...you would see: [src/main.rs:4] x == 1 = false [src/main.rs:8] x = 0 As seen in the previous section, where the higher order function call_unsafe_fn_ptr is called, you may now also call dbg! without passing any arguments. This is useful when tracing what branches your application takes. For example, with: fn main() { let condition = true; if condition { dbg!(); } } ...you would see: src/main.rs:5] Library stabilizations In 1.35.0, a number of APIs have become stable. In addition, some implementations were added and other changes occured as well. See the detailed release notes for more details. Copy the sign of a floating point number onto another With this release, new methods copysign have been added to the floating point primitive types f32 and f64:<img src="http://feeds.feedburner.com/~r/tweakers/mixed/~4/xkcwycE15q0" height="1" width="1" alt=""/>
